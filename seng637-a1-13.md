>   **SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#1 – Introduction to Testing and Defect Tracking**

| Group: 13      |
|-----------------|
| Student 1 Kundai Dziwa                |   
| Student 2 Matin Ashoori              |   
| Student 3 Behzad Fuladpanjeh Hojaghan              |   
              |   


**Table of Contents**

(When you finish writing, update the following list using right click, then
“Update Field”)

[1 Introduction	1](#_Toc439194677)

[2 High-level description of the exploratory testing plan	1](#_Toc439194678)

[3 Comparison of exploratory and manual functional testing	1](#_Toc439194679)

[4 Notes and discussion of the peer reviews of defect reports	1](#_Toc439194680)

[5 How the pair testing was managed and team work/effort was
divided	1](#_Toc439194681)

[6 Difficulties encountered, challenges overcome, and lessons
learned	1](#_Toc439194682)

[7 Comments/feedback on the lab and lab document itself	1](#_Toc439194683)

# Introduction

The Test Plan is designed to prescribe the scope, approach, resources, and schedule of all testing activities for the ATM Simulation System. The plan identifies the features to be tested, the types of testing to be performed, and how we will partake in getting the testing done. The primary goal of testing is to verify that the ATM system correctly supports all required customer and operator functions, handles normal and exceptional scenarios safely, and communicates properly with the bank system with accurate transaction logging. 

Prior to this lab, our group did have an understanding of simple testing and debugging. We learned it in ENSF 607 - Advanced Software Design and Architecture. Essentially, the exploratory testing is a user or multiple users would test the program by just checking the software functionality by randomly interacting with the program. While unit testing is a methodological approach for testing, each functionality such as buttons, and input field. This lab requiers our group to work with JIra, however, none of our group members has  worked with the program prior to this course.

# High-level description of the exploratory testing plan

The exploratory testing approach focuses on navigating the ATM system through its most common real world use case scenarios. This method emphasizes evaluating the system from a typical user’s perspective, making standard workflows and frequent transaction paths the primary means of identifying defects. In addition, boundary conditions and common edge cases will be tested to assess how the system behaves under slightly stressed or unusual conditions.
Using the limited documentation in regards to the ATM requirements we found the common workflows in which we would traverse. We would be acting as a user who would insert a card and withdraw, deposit, transfer funds, check balance, etc.

# Comparison of exploratory and manual functional testing

For this lab, we had to utilize both exploratory and manual functional testing. Exploratory testing is where a user randomly explores the functionality of the program, whereas manual functional testing requires a systematic approach. The systematic approach requires the tester to think of all the different functionalities of buttons and input fields to see if it behaves as intended.  

For exploratory testing, we found that it was very effective in discovering edge case logic and spelling mistakes in the UI, which was not a requirement in manual functional testing. The manual functional testing would ask if the message woudld show but not specify if the message was correctly written. For example, BR-2 had a typo "Wood you like", and another example would be testing multiple transactions, from transaction one to two; it would skip the two and output three. The positive of exploratory testing is that the tester is not confiding a list of potential issues; it is up to the tester to explore bugs that were not thought of in manual functional testing. The downside of exploratory testing is that it does not gurantee that the tester would cover the full requirements of testing.  

In the manual functional test, there was a scripted test that was provided in appendix C of the assignment. The scripted test was made to ensure all the core business requierments, so that each iteration of the program can be tested in the same manner to check if fixing one issue did not break another part of the program. This process is highly effective for repeatability and to compare two different versions; however, this process is very time consuming, especially when a program is bigger than the program we tested. 

In conclusion, we learned that both types of testing is required because they complement each other's weaknesses. 

# Notes and discussion of the peer reviews of defect reports

Comparing the results from version 1.0 and 1.1, we found that certain exploratory bugs were fixed, however majority of the bugs were not or either in progress. Meaning that a spelling mistake was corrected, however, another spelling mistake was made. Or an incorrect balance was closer to the correct balance but still wrong. With regression testing, we found that when a certain test passed in version 1.0, it failed in version 1.1. This issue can arise when trying to debug the code and not realizing one change can affect another area, suggesting that the code is highly coupled.  

# How the pair testing was managed and team work/effort was divided 

We performed the pair testing by dividing and splitting up tasks appropriately between different testers, both at a high level and low level of testing. We seperated the exploratory, manual, and regression testing into different phases in which each tester would take on a phase. Then within each high level testing phase, we would have another tester be assigned to bugs for them to review and complete.

# Difficulties encountered, challenges overcome, and lessons learned

There weren't too many difficulties surrouding the testing process as we were able to identify and see the fixes of version 1.0 in version 1.1. The challenges that we faced stemmed around us needing to understand the fully the requirements of the ATM. There were a few cases where we may have understood a feature that was purposefully built into the system as a bug or an issue. This allowed us to wrap our heads around the deep importance of early documentation in building software. It will not only be needed for building out the system better but also to better maintain the system in the future.

# Comments/feedback on the lab and lab document itself

The lab was made well to allow us to learn through a hands on method. This was more effective in understanding the different sections that are needed for properly testing a system. We also learned how to utilize Jira, however, more practice requires 
